/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-BSD-5-Clause-Nordic
 */

 /* File: motion_circle_notimer.c */

#include <zephyr.h>
#include <drivers/gpio.h>

#include "circle_test.h"
#include "event_manager.h"
#include "button_event.h"
#include "motion_event.h"
#include "hid_event.h"

#define MODULE motion
#include "module_state_event.h"

#include <logging/log.h>
LOG_MODULE_REGISTER(MODULE, CONFIG_DESKTOP_MOTION_LOG_LEVEL);


#define LED_ON	0
#define LED_OFF	1

#define MOTION_SEND			29
#define STATE_PEND_CONN		30
#define DRAW_HANDLE			31

enum state {
	STATE_IDLE,
	STATE_CONNECTED,
	STATE_PENDING
};


enum dir {
	DIR_START,
	DIR_STOP,

	DIR_COUNT
};





static struct device *led_port;
	
static s8_t circle_data[2];

static enum state state;


static bool is_motion_active = false;


static void motion_event_send(s16_t dx, s16_t dy)
{
	struct motion_event *event = new_motion_event();

	event->dx = dx;
	event->dy = dy;

	EVENT_SUBMIT(event);
}

static enum dir key_to_dir(u16_t key_id)
{
	enum dir dir = DIR_COUNT;
	
		
	switch (key_id) {
	case CONFIG_DESKTOP_MOTION_START_ID:
		dir = DIR_START;
		break;

	case CONFIG_DESKTOP_MOTION_STOP_ID:
		dir = DIR_STOP;
		break;	

	default:
		break;
	}

	return dir;
}


static void send_motion(void)
{
<<<<<<< HEAD
	gpio_pin_set(led_port, MOTION_SEND, 1);
=======
	//gpio_pin_write(led_port, 29, 1);
>>>>>>> Fix motion_circle.c issue

	motion_event_send((s16_t)circle_data[0], (s16_t)circle_data[1]);
	
<<<<<<< HEAD
	gpio_pin_set(led_port, MOTION_SEND, 0);
=======
	//gpio_pin_write(led_port, 29, 0);
>>>>>>> Fix motion_circle.c issue
}


static int leds_init(void)
{
	led_port = device_get_binding(DT_ALIAS_LED0_GPIOS_CONTROLLER);
		
	if (!led_port) {
		LOG_ERR("Could not bind to LED port %s",
			DT_ALIAS_LED0_GPIOS_CONTROLLER);
		return -EIO;
	}
	
	int err = gpio_pin_configure(led_port, DT_ALIAS_LED2_GPIOS_PIN, GPIO_OUTPUT);
	
	if (err) {
	LOG_ERR("Unable to configure Start/Stop LED, err %d", err);
	led_port = NULL;
	return err;
	}
	
	if(led_port != NULL) {
		(void)gpio_pin_set(led_port, DT_ALIAS_LED2_GPIOS_PIN, LED_OFF); 
	}
 /**  For Testing purpose only 
<<<<<<< HEAD
  */		
	err = gpio_pin_configure(led_port, MOTION_SEND, GPIO_OUTPUT);
=======
  *			
	err = gpio_pin_configure(led_port, 31 , GPIO_DIR_OUT);
>>>>>>> Fix motion_circle.c issue
	if (err) {
	LOG_ERR("Unable to config pin31, err %d", err);
	led_port = NULL;
	return err;
	}
	
<<<<<<< HEAD
	(void)gpio_pin_configure(led_port, STATE_PEND_CONN , GPIO_OUTPUT);
	(void)gpio_pin_configure(led_port, DRAW_HANDLE, GPIO_OUTPUT);
 
=======
	(void)gpio_pin_configure(led_port, 30 , GPIO_DIR_OUT);
	(void)gpio_pin_configure(led_port, 29 , GPIO_DIR_OUT);
 */
>>>>>>> Fix motion_circle.c issue
	return 0;
 
 
}	

void draw_circle_handler(void)
{
	
<<<<<<< HEAD
	(void)gpio_pin_set(led_port, DRAW_HANDLE, 1);
=======
static const s16_t s_delta_x[] = {0, -1, -3, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15, -14, -13, -11, -9, -7, -5, -3, 0, 1, 4, 6, 8, 10, 12, 13, 15, 15, 15, 15, 15, 14, 12, 11, 9, 7, 4, 2, 0, -2, -5, -7, -9, -11, -13, -14, -15, -15, -15, -15, -14, -13, -12, -10, -8, -6, -4, -1, 0, 3, 5, 7, 10, 11, 13, 14, 15, 15, 15, 15, 14, 13, 12, 10, 8, 6, 3, 1, -1, -3, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15, -14, -13, -11, -9, -7, -5, -3, 0, 2, 4, 6, 9, 11, 12, 14, 15, 15, 15, 15, 15, 14, 12, 11, 9, 7, 4, 2, 0, -2, -5, -7, -9, -11, -13, -14, -15, -15, -15, -15, -14, -13, -12, -10, -8, -6, -4, -1, 0, 3, 5, 8, 10, 11, 13, 14, 15, 15, 15, 15, 14, 13, 12, 10, 8, 5, 3, 1, -1, -3, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15, -14, -13, -11, -9, -7, -5, -2, 0, 2, 4, 6, 9, 11, 12, 14, 15, 15, 15, 15, 15, 14, 12, 11, 9, 7, 4, 2, 0, -2, -5, -7, -9, -11, -13, -14, -15, -15, -15, -15, -14, -13, -12, -10, -8, -6, -4, -1, 0, 3, 5, 8, 10, 11, 13, 14, 15, 15, 15, 15, 14, 13, 11, 10, 8, 5, 3, 0, -1, -4, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15, -14, -13, -11, -9, -7, -5, -2, 0, 2, 4, 7, 9, 11, 12, 14, 15, 15, 15, 15, 15, 14, 12, 11, 9, 6, 4, 2, 0, -2, -5, -7, -9, -11, -13, -14, -15, -15, -15, -15, -14, -13, -12, -10, -8, -6, -3, -1, 1, 3, 5, 8, 10, 12, 13, 14, 15, 15, 15, 15, 14, 13, 11, 10, 8, 5, 3, 0, -1, -4, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15,  -14, -13, -11, -9, -7, -5, -2, 0, 2, 4, 7, 9, 11, 12, 14, 15, 15, 15, 15, 15, 14, 12, 11, 9, 6, 4, 2, 0, -3, -5, -7};

static const s16_t s_delta_y[] = {0, 15, 15, 14, 13, 11, 10, 8, 5, 3, 0, -1, -4, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15, -14, -13, -11, -9, -7, -5, -2, 0, 2, 4, 7, 9, 11, 12, 14, 15, 15, 15, 15, 15, 14, 12, 11, 9, 6, 4, 2, 0, -2, -5, -7, -9, -11, -13, -14, -15, -15, -15, -15, -14, -13, -12, -10, -8, -6, -3, -1, 1, 3, 5, 8, 10, 12, 13, 14, 15, 15, 15, 15, 14, 13, 11, 10, 8, 5, 3, 0, -1, -4, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15, -14, -13, -11, -9, -7, -5, -2, 0, 2, 4, 7, 9, 11, 12, 14, 15, 15, 15, 15, 15, 14, 12, 11, 9, 6, 4, 2, 0, -3, -5, -7, -9, -11, -13, -14, -15, -15, -15, -15, -14, -13, -12, -10, -8, -6, -3, -1, 1, 3, 6, 8, 10, 12, 13, 14, 15, 15, 15, 15, 14, 13, 11, 10, 7, 5, 3, 0, -1, -4, -6, -8, -10, -12, -13, -14, -15, -15, -15, -15, -14, -13, -11, -9, -7, -5, -2, 0, 2, 4, 7, 9, 11, 12, 14, 15, 15, 15, 15, 15, 13, 12, 10, 8, 6, 4, 1, 0, -3, -5, -7, -9, -11, -13, -14, -15, -15,  -15, -15, -14, -13, -12, -10, -8, -6, -3, -1, 1, 3, 6, 8, 10, 12, 13, 14, 15, 15, 15, 15, 14, 13, 11, 9, 7, 5, 3, 0, -1, -4, -6, -8, -10, -12, -13, -15, -15, -15, -15, -15, -14, -12, -11, -9, -7, -4, -2, 0, 2, 5, 7, 9, 11, 13, 14, 15, 15, 15, 15, 14, 13, 12, 10, 8, 6, 4, 1, 0, -3, -5, -7, -10, -11, -13, -14, -15, -15, -15, -15, -14, -13, -12, -10, -8, -6, -3, -1, 1, 3, 6, 8, 10, 12, 13, 14, 15, 15, 15, 15, 14, 13, 11, 9, 7, 5, 3, 0, -2, -4, -6, -9, -11, -12, -14, -15, -15, -15, -15, -15, -14, -12, -11, -9, -7, -4, -2, 0, 2, 5, 7, 9, 11, 13, 14, 15, 15, 15, 15, 14, 13};
			
static s32_t s_idx = 0; 
  
	//(void)gpio_pin_write(led_port,31, 1);
  
	x =  s_delta_x[s_idx];
	y =  s_delta_y[s_idx];
>>>>>>> Fix motion_circle.c issue


	circle_test_get(circle_data);

<<<<<<< HEAD
=======
	if (s_idx >= (sizeof(s_delta_x) / sizeof(s_delta_x[0])))
	{
		s_idx = 0;
	}
	else if (s_idx < 0)
	{
		s_idx = (sizeof(s_delta_x) / sizeof(s_delta_x[0]));
	}
>>>>>>> Fix motion_circle.c issue

	//LOG_INF("s_idx = %i",s_idx);

	is_motion_active = true;
		
   	if (state == STATE_CONNECTED) {	
		send_motion();
		LOG_INF("Send motion");
		state = STATE_PENDING;
<<<<<<< HEAD
		gpio_pin_set(led_port, STATE_PEND_CONN , 0);
	}
	(void)gpio_pin_set(led_port,DRAW_HANDLE, 0);
=======
		//gpio_pin_write(led_port, 30, 0);
	}
	//void)gpio_pin_write(led_port,31, 0);
>>>>>>> Fix motion_circle.c issue
	
	is_motion_active = false;
}


static bool handle_button_event(const struct button_event *event)
{
	enum dir dir = key_to_dir(event->key_id);

	
	if (dir == DIR_COUNT) {
				
		return false;
	}

	
	if(dir == DIR_START)
	{
		

		draw_circle_handler();
		/* Lit LED3 */
		if(led_port != NULL) {
			(void)gpio_pin_set(led_port, DT_ALIAS_LED2_GPIOS_PIN, LED_ON); 
		}
	    LOG_INF("Button event: Start button pressed");
	}
			
	else if(dir == DIR_STOP)
	{

		is_motion_active = false;
		if(state == STATE_PENDING)  
			state = STATE_CONNECTED;
		
		/* Off LED3 */
			if(led_port != NULL) {
			(void)gpio_pin_set(led_port, DT_ALIAS_LED2_GPIOS_PIN, LED_OFF); 
		}
		LOG_INF("Button event: Stop button pressed");
	}
			
	return true;
}

static bool handle_module_state_event(const struct module_state_event *event)
{
	(void)leds_init();
	
	/* Replicate the state of buttons module */
	if (event->module_id == MODULE_ID(buttons)) {
		module_set_state(event->state);
	}

	return false;
}


static bool handle_hid_report_sent_event(const struct hid_report_sent_event *event)
{
	if (event->report_id == REPORT_ID_MOUSE) {
		
		
		if (state == STATE_PENDING) {
			if (is_motion_active) {
			
				//LOG_INF("HID_REPORT_SEND EVENT: STATE CONNECTED");
				state = STATE_CONNECTED;
<<<<<<< HEAD
				gpio_pin_set(led_port, STATE_PEND_CONN, 1);
				draw_circle_handler();
			
=======
				//gpio_pin_write(led_port, 30, 1);
>>>>>>> Fix motion_circle.c issue
			}
		
		}
	}

	return false;
}

static bool handle_hid_report_subscription_event(const struct hid_report_subscription_event *event)
{
	if (event->report_id == REPORT_ID_MOUSE) {
		static u8_t peer_count;

		if (event->enabled) {
			__ASSERT_NO_MSG(peer_count < UCHAR_MAX);
			peer_count++;
		} else {
			__ASSERT_NO_MSG(peer_count > 0);
			peer_count--;
		}

		bool is_connected = (peer_count != 0);

		if ((state == STATE_IDLE) && is_connected) {
			if (is_motion_active) {
				send_motion();
				state = STATE_PENDING;
<<<<<<< HEAD
				gpio_pin_set(led_port, STATE_PEND_CONN, 0);
=======
				//gpio_pin_write(led_port, 30, 0);
>>>>>>> Fix motion_circle.c issue
			} else {
				//LOG_INF("SUBSCRIPTION EVENT: STATE CONNECTED");
				state = STATE_CONNECTED;
<<<<<<< HEAD
				gpio_pin_set(led_port, STATE_PEND_CONN, 1);
=======
				//gpio_pin_write(led_port, 30, 1);
>>>>>>> Fix motion_circle.c issue
			}
			return false;
		}
	
		if ((state != STATE_IDLE) && !is_connected) {
			state = STATE_IDLE;
			return false;
		}
	}

	return false;
}

static bool event_handler(const struct event_header *eh)
{
	
	
	if (is_hid_report_sent_event(eh)) {
		return handle_hid_report_sent_event(
				cast_hid_report_sent_event(eh));
	}

	if (is_button_event(eh)) {
		return handle_button_event(cast_button_event(eh));
	}

	if (is_module_state_event(eh)) {
		return handle_module_state_event(cast_module_state_event(eh));
	}

	if (is_hid_report_subscription_event(eh)) {
		return handle_hid_report_subscription_event(
				cast_hid_report_subscription_event(eh));
	}

	/* If event is unhandled, unsubscribe. */
	__ASSERT_NO_MSG(false);

	return false;
}
EVENT_LISTENER(MODULE, event_handler);
EVENT_SUBSCRIBE_EARLY(MODULE, button_event);
EVENT_SUBSCRIBE(MODULE, module_state_event);
EVENT_SUBSCRIBE(MODULE, hid_report_sent_event);
EVENT_SUBSCRIBE(MODULE, hid_report_subscription_event);
